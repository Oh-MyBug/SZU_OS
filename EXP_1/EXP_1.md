[TOC]

### 实验目的与要求

#### 实验目的

​		通过进程的创建、撤销和运行加深对进程概念和进程并发执行的理解，明确进程与程序之间的区别。

#### 实验要求

1、 掌握在在linux中编程编译运行的方法

2、 阅读例程，理解函数fork()、execl()、exit()、getpid()和waitpid()的功能和用法

3、 运行例程，分析例程中关键代码的功能，给出运行结果并对运行结果进行分析说明。

4、 模仿例程，编写一段程序实现以下功能：

​		a)  使用系统调用fork()创建两个子进程

​		b)  各个子进程显示和输出一些提示信息和自己的进程标识符。

​		c)  父进程显示自己的进程ID和一些提示信息，然后调用waitpid()等待多个子进程结束，并在子进程结束后显示输出提示信息表示程序结束。

5、 创建多个（3个以上）进程并发运行，控制好各个子进程输出自己的进程标识符和一些提示信息，对程序运行结果进行分析说明。观察各个子进程并发执行的顺序，输出结果是否与设想中的顺序不同，并分析原因。

###  方法、步骤：

(说明程序相关的算法原理或知识内容，程序设计的思路和方法，可以用流程图表述，程序主要数据结构的设计、主要函数之间的调用关系等)

​		fork函数调用用于创建一个新进程，称为子进程，它与进程（称为系统调用fork的进程）同时运行，此进程称为父进程。创建新的子进程后，两个进程将执行fork（）函数调用之后的下一条指令。子进程使用相同的pc（程序计数器），相同的CPU寄存器，在父进程中使用的相同打开文件。

<img src = "fig\image001.png" width = 70%>



<img src = "fig\image003.png" width = 25%>

​		当使用fork函数循环创建多个子进程时，如下代码：

<img src = "fig\image005.png" width = 70%>

​		虽然程序只循环了三次，但是根据fork函数的原理，实际上会产生1+2+4=8个子进程，流程图如下：

<img src = "fig\image007.png" width = 60%>

​		因此，如果需要“子进程完全由父进程产生”，那么可以通过break关键字控制循环，并通过循环因子判断是第几个孩子。代码如下（生成3个子进程）：

<img src = "fig\image009.png" width = 70%>

### 实验过程及内容

(对程序代码进行说明和分析，越详细越好，代码排版要整齐，可读性要高)

#### 例程1：最简单的程序，测试开发环境是否正常

<img src = "fig\image011.png" width = 40%>

#### 例程2：单个子程序的创建

<img src = "fig\image013.png" width = 100%>

#### 例程3：在子进程中调用外部命令

**备注：在之前的例程中出现过的相关头文件以及函数之后都不再说明**

<img src = "fig\image015.png" width = 80%>

#### 实验内容4程序：编写程序实现三种功能（详细功能见实验内容4）

<img src = "fig\image017.png" width = 80%>

#### 实验内容5程序：编写程序实现对应功能（详细功能见实验内容5）

<img src = "fig\image019.png" width = 80%>

####   实验结论

（提供运行结果，对结果进行探讨、分析、评价，并提出结论性意见和改进想法）  

#### 例程1：最简单的程序，测试开发环境是否正常

<img src = "fig\image021.png" width = 80%>

#### 例程2：单个子程序的创建

<img src = "fig\image023.png" width = 80%>

#### 例程3：在子进程中调用外部命令

<img src = "fig\image025.png" width = 80%>

####  实验内容4程序：编写程序实现三种功能（详细功能见实验内容4）

<img src = "fig\image027.png" width = 80%> 

#### 实验内容5程序：编写程序实现对应功能（详细功能见实验内容5） 

<img src = "fig\image029.png" width = 80%>                   

<img src = "fig\image031.png" width = 80%>                                                 

​		观察可发现：各个子进程并发执行的顺序并不是固定的，所以调用fork()后，无法确定子进程间谁将率先访问CPU。  

1. 在多处理器系统中，它可能同时各自访问一个CPU。  
2. 在单处理器系统中，fork()之后很可能总是先调度父进程（优化性能），但如果恰好父进程的CPU时间片到期了，则执行子进程。  

### 实验体会

​		课堂上认真听老师讲课，下课后再看其他视频进行相关知识面的扩充，再加上之前学习线程时的见解，对于这次实验而言还是可以好好完成的。希望之后也能认真完成相应的实验！ 